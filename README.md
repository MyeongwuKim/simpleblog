# SimpleBlog (1인개발)

> Next.js + Prisma + MongoDB 기반 개인 블로그 서비스

🔗 **Deployment URL**
👉 https://mw-simpleblog.vercel.app

------------------------------------------------------------------------

## 📌 Summary

-   velog를 기반으로 만든 사진 글을 작성/관리할 수 있는 개인 블로그
    서비스
-   **Next.js 14/15 기반**으로 App Router와 **React Query v5** 학습 및
    적용
-   **Prisma + MongoDB**를 사용해 게시글, 태그, 댓글 모델링 및 데이터
    관리
-   **주요 기능**
    -   ✍️ react-markdown을 통한 글 작성 / 수정 / 삭제
    -   👤 프로필 작성 및 수정
    -   📝 임시 저장글 관리
    -   💬 코멘트 작성 및 삭제
    -   🔑 next-auth 기반 oAuth 로그인
    -   🏷️ 태그 등록 및 필터링
    -   ♾️ 무한 스크롤 및 로딩 스켈레톤
    -   📱💻 반응형 레이아웃

------------------------------------------------------------------------

## 📖 Background

Next.js 13으로 만들었던 이전 블로그는 UI/UX적으로 부족함을 느꼈고,
Next.js 버전도 오래되어 확장성에 한계가 있었습니다.
그래서 이번에는 단순 CRUD가 아니라, **캐싱 전략·무한 스크롤·태그
관리·이미지 관리**까지 실제 서비스 패턴을 적용하는 걸 목표로 삼았습니다.

그리고 React Query, Prisma, Jest 같은 기술들을 직접 실험해보면서
"실제 프로덕션에서 어떻게 동작할까?"를 스스로 만들어보는 학습 공간으로
사용했습니다.

------------------------------------------------------------------------

## 💡 What I Learned

이번 프로젝트에서는 **성능 최적화와 불필요한 렌더링 최소화**에 많은
시간을 들였습니다.
`useMemo`, `useCallback`을 적절하게 활용하고, React DevTools로 렌더링
흐름을 분석하며 구조적으로 최적화했습니다.

Next.js의 **SSR, ISR, 캐시 무효화(`revalidateTag`)**를 실제로
적용해보며
React Query와 Next.js의 캐싱 레이어 차이를 직접 비교했습니다.
이 과정에서:

-   `staleTime`·`gcTime`
-   prefetch → hydration 흐름
-   서버 캐싱 vs 클라이언트 캐싱의 우선순위

같은 요소들을 경험적으로 이해하게 되었고,
각 화면에서 어떤 전략을 써야 가장 자연스러운지 판단할 수 있게
되었습니다.

또한 Lighthouse로 **LCP와 성능 점수**를 확인하며 실제 유저 경험 개선
효과를 측정했습니다.
마지막으로 Jest + MSW를 활용해 기본적인 테스트를 작성해
리팩토링 과정에서도 기능이 안정적으로 유지되도록 했습니다.

한 달 반 동안 **데이터 캐싱, 무한스크롤, 태그 필터링, 이미지 정리 로직,
Jest 테스트**까지 직접 구현하며
Next.js + React Query 생태계를 훨씬 깊게 이해할 수 있었습니다.

------------------------------------------------------------------------

# 🔥 Challenges & Solutions

아래는 프로젝트를 진행하면서 **가장 고민했던 부분과 해결 과정**을 화면
단위 + 시스템 단위로 정리한 내용입니다.

------------------------------------------------------------------------

## 🧠 React Query를 화면에 맞게 가장 효율적으로 사용하는 방법

이번 프로젝트에서 가장 많이 고민한 것은
**"React Query를 화면 특성에 맞게 설계하는 방법"**이었습니다.

-   staleTime을 어디까지 줄지 늘릴지
-   prefetch가 도움이 되는 화면과 오히려 방해되는 화면
-   hydration 이후 언제 refetch해야 자연스러운지
-   setQueryData 사용 타이밍
-   invalidateQueries가 필요한 상황
-   Next.js 서버 캐싱과 충돌하지 않도록 조합하는 방법
-   infiniteQuery에서 refetch를 어떻게 최소화할지

이런 요소들을 화면별로 실험하면서
**React Query를 단순 fetch 도구가 아니라, UI/UX 흐름을 설계하는 핵심
도구로** 활용했습니다.

------------------------------------------------------------------------

# 1) 📝 게시글(Post) -- 가장 최신성이 중요한 영역

### ✔ 게시글 목록

게시글은 업데이트와 접근 빈도가 많기 때문에,
**prefetch를 제거하고 항상 fresh fetch** 전략을 적용했습니다.

-   prefetch 제거 → 페이지 진입 시 항상 최신 게시글
-   새 글 작성 시 `setQueryData`로 목록 UI 즉시 반영
-   staleTime 최소화로 최신성 유지

------------------------------------------------------------------------

### ✔ 게시글 디테일

디테일은 자주 업데이트 되지 않는 화면이기에 fetch 처리를 특정한 부분에서만 할수있게 처리했습니다.

-   prefetch → 첫 로딩 속도 확보
-   staleTime: 0 → 렌더 직전 최신 데이터로 갱신
-   글 수정 시, **Next.js 서버에서 `revalidateTag`로 캐시 무효화** + 클라이언트에선 React-query 캐시무효화
-   다른 유저도 수정 즉시 최신 글을 볼 수 있도록 서버에서 최신성 보장

------------------------------------------------------------------------

# 2) 👤 프로필(Profile)

프로필은 자주 업데이트되지 않으므로 많은 고민후에 **ISR**을 사용했습니다.

-   `revalidate = 300` → 5분마다 서버 최신화
-   기본적으로 캐시된 데이터로 즉시 렌더링
-   수정 시 → `setQueryData`로 UI만 빠르게 업데이트

------------------------------------------------------------------------

# 3) 💬 방명록(Guestbook) -- 무한스크롤 특성에 맞춘 절충

방명록은 스크롤 기반으로 동작하는 화면이라,
스크롤 UX는 유지하면서도 데이터 최신성도 어느 정도 확보해야 하는
중간 지점이 필요한 구조였습니다.

그래서 완전한 fresh fetch까지는 아니더라도,
불필요한 refetch를 최소화하면서 자연스럽게 최신 데이터를 반영하는 방식으로 구성했습니다.

-   `useInfiniteQuery` 적용
-   적당한 `staleTime`으로 refetch 과다 방지
-   새 댓글 작성 시 `invalidateQueries` 또는 `setQueryData`

------------------------------------------------------------------------

# 4) 🗑️ 이미지 정리(Image Cleanup) – 사용되지 않는 이미지 자동 삭제

게시글 작성·수정·임시글 기능을 구현하면서  
Cloudflare에 업로드된 이미지가 실제로는 더 이상 사용되지 않는데  
계속 남아버리는 **고아 이미지(orphan image)** 문제가 발생했습니다.

(예: 글 삭제, 임시글 취소, 수정 중 이미지 교체 등)

이를 해결하기 위해 다음과 같은 구조를 적용했습니다.

### ✔ 1) Post–Image 관계를 활용한 고아 이미지 식별
Image 모델은 Post와 **1:N 관계**로 설계되어 있어  
`postId` 존재 여부만으로 이미지 사용 여부를 명확하게 확인할 수 있습니다.

- `postId` 있음 → 사용 중인 이미지  
- `postId` 없음 → 고아 이미지  

---

### ✔ 2) Vercel Cron + Cloudflare API로 자동 정리

매일 새벽 자동으로 다음 작업이 실행됩니다.

1. `postId`가 null인 이미지 조회  
2. Cloudflare API로 실제 이미지 삭제  
3. DB에서 Image 레코드 삭제  

→ Cloudflare 저장소가 불필요하게 커지지 않도록 **완전 자동화된 정리 구조**를 구축했습니다.

---

------------------------------------------------------------------------

## 🛠 Technology Stack

-   **Frontend:** Next.js 14/15, React, TypeScript, React Query v5,
    TailwindCSS, Flowbite-React
-   **Backend:** Prisma, MongoDB
-   **Testing:** Jest, MSW
-   **Deployment:** Vercel

------------------------------------------------------------------------

## ⚙️ Setup & Usage

``` bash
npm run demo
```
