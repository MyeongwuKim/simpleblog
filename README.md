# SimpleBlog (1인개발)

> Next.js + Prisma + MongoDB 기반 개인 블로그 서비스

🔗 **Deployment URL**
👉 https://mw-simpleblog.vercel.app

------------------------------------------------------------------------

## 📌 Summary

-   velog를 기반으로 만든 사진 글을 작성/관리할 수 있는 개인 블로그
    서비스
-   **Next.js 14/15 기반**으로 App Router와 **React Query v5** 학습 및
    적용
-   **Prisma + MongoDB**를 사용해 게시글, 태그, 댓글 모델링 및 데이터
    관리
-   **주요 기능**
    -   ✍️ react-markdown을 통한 글 작성 / 수정 / 삭제
    -   👤 프로필 작성 및 수정
    -   📝 임시 저장글 관리
    -   💬 코멘트 작성 및 삭제
    -   🔑 next-auth 기반 oAuth 로그인
    -   🏷️ 태그 등록 및 필터링
    -   ♾️ 무한 스크롤 및 로딩 스켈레톤
    -   📱💻 반응형 레이아웃

------------------------------------------------------------------------

## 📖 Background

Next.js 13으로 만들었던 이전 블로그는 UI/UX적으로 부족함을 느꼈고,
Next.js 버전도 오래되어 확장성에 한계가 있었습니다.
그래서 이번에는 단순 CRUD가 아니라, **캐싱 전략·무한 스크롤·태그
관리·이미지 관리**까지 실제 서비스 패턴을 적용하는 걸 목표로 삼았습니다.

그리고 React Query, Prisma, Jest 같은 기술들을 직접 실험해보면서
"실제 프로덕션에서 어떻게 동작할까?"를 스스로 만들어보는 학습 공간으로
사용했습니다.

------------------------------------------------------------------------

## 💡 What I Learned

이번 프로젝트에서는 **성능 최적화와 불필요한 렌더링 최소화**에 많은
시간을 들였습니다.
`useMemo`, `useCallback`을 적절하게 활용하고, React DevTools로 렌더링
흐름을 분석하며 구조적으로 최적화했습니다.

Next.js의 **SSR, ISR, 캐시 무효화(`revalidateTag`)**를 실제로
적용해보며
React Query와 Next.js의 캐싱 레이어 차이를 직접 비교했습니다.
이 과정에서:

-   `staleTime`·`gcTime`
-   prefetch → hydration 흐름
-   서버 캐싱 vs 클라이언트 캐싱의 우선순위

같은 요소들을 경험적으로 이해하게 되었고,
각 화면에서 어떤 전략을 써야 가장 자연스러운지 판단할 수 있게
되었습니다.

또한 Lighthouse로 **LCP와 성능 점수**를 확인하며 실제 유저 경험 개선
효과를 측정했습니다.
마지막으로 Jest + MSW를 활용해 기본적인 테스트를 작성해
리팩토링 과정에서도 기능이 안정적으로 유지되도록 했습니다.

한 달 반 동안 **데이터 캐싱, 무한스크롤, 태그 필터링, 이미지 정리 로직,
Jest 테스트**까지 직접 구현하며
Next.js + React Query 생태계를 훨씬 깊게 이해할 수 있었습니다.

------------------------------------------------------------------------

## 🔥 Challenges & Solutions

이번 프로젝트에서 가장 많이 고민한 것은
**"React Query"**를 화면 특성에 맞게 설계하는 방법이었습니다.

-   staleTime을 어디까지 줄지 늘릴지
-   prefetch가 도움이 되는 화면과 오히려 방해되는 화면
-   hydration 이후 언제 refetch해야 자연스러운지
-   setQueryData 사용 타이밍
-   invalidateQueries가 필요한 상황
-   Next.js 서버 캐싱과 충돌하지 않도록 조합하는 방법
-   infiniteQuery에서 refetch를 어떻게 최소화할지

------------------------------------------------------------------------

### 1) 📝 게시글(Post)

초기에는 prefetch를 사용해 SSR로 데이터를 가져오는 방식으로 구현했습니다.
하지만 이 방식은 새로고침을 해도 최신 데이터가 반영되지 않는 문제가 있었습니다.
SSR 기반 prefetch는 한 번 서버에서 렌더링된 결과를 그대로 재사용하므로,
Next.js 서버 캐시가 갱신되지 않는 한 항상 동일한 목록만 표시되는 구조였습니다.

게시글은 작성·삭제·수정 등 업데이트가 빈번하고 접근도 많기 때문에
이전 데이터가 남아 있는 SSR prefetch 방식으로는 최신성을 보장할 수 없었습니다.

그래서 게시글 목록은 prefetch를 제거하고,
페이지 진입 시마다 fresh fetch로 최신 데이터를 가져오는 방식으로 전환했습니다.
또한 UI와 서버 데이터의 일관성을 유지하기 위해 아래와같이 구성하였습니다.

#### ✔ 게시글 목록

-   prefetch 제거 → 페이지 진입 시 항상 최신 게시글
-   글 작성/삭제 시 `setQueryData`를 사용하여 게시글 목록 UI 즉시 반영
-   글 작성/삭제 시 `invalidateQueries` 와 `revalidateTag`를 사용하여 데이터를 최신화함

#### ✔ 게시글 디테일

-   prefetch → 첫 로딩 속도 확보
-   staleTime: 0 → 렌더 직전 최신 데이터로 갱신
-   글 수정 시, **Next.js 서버에서 `revalidateTag`로 캐시 무효화** + 클라이언트에선 React-query 캐시무효화
-   다른 유저도 수정 즉시 최신 글을 볼 수 있도록 서버에서 최신성 보장

------------------------------------------------------------------------

### 2) 👤 프로필(Profile)

프로필 페이지는 실제로 변경이 거의 일어나지 않는 정적인 성격의 화면이기 때문에,
매 요청마다 서버에서 데이터를 다시 가져오는 방식은 불필요하다고 판단했습니다.

특히 프로필은 “읽기 중심”의 페이지라서 최신성이 아주 민감한 화면도 아니고,
반대로 빈번한 DB 조회나 네트워크 요청이 발생하면 오히려 비효율적일 수 있습니다.

이런 특성을 고려해 여러 렌더링 방식을 비교한 끝에,
**Next.js의 ISR(Incremental Static Regeneration)**을 적용하는 것이 가장 적합하다고 생각했습니다.

-   `revalidate = 300` → 5분마다 서버 최신화
-   기본적으로 캐시된 데이터로 즉시 렌더링
-   수정 시 → `setQueryData`로 UI만 빠르게 업데이트

------------------------------------------------------------------------

### 3) 💬 방명록(Guestbook)

방명록은 스크롤 기반으로 동작하는 화면이라,
스크롤 UX는 유지하면서도 데이터 최신성도 어느 정도 확보해야 하는
중간 지점이 필요한 구조였습니다.

그래서 완전한 fresh fetch까지는 아니더라도,
불필요한 refetch를 최소화하면서 자연스럽게 최신 데이터를 반영하는 방식으로 구성했습니다.

-   `useInfiniteQuery` 적용
-   적당한 `staleTime`으로 refetch 과다 방지
-   새 댓글 작성 시 `invalidateQueries` 또는 `setQueryData`

------------------------------------------------------------------------

### 4) 🗑️ 이미지 정리(Image Cleanup)

게시글 작성·수정·임시글 기능을 구현하면서  
Cloudflare에 업로드된 이미지가 실제로는 더 이상 사용되지 않는데  
계속 남아버리는 **고아 이미지(orphan image)** 문제가 발생했습니다.

(예: 글 삭제, 임시글 취소, 수정 중 이미지 교체 등)

이를 해결하기 위해 다음과 같은 구조를 적용했습니다.

#### ✔ Post–Image 관계를 활용한 고아 이미지 식별
Image 모델은 Post와 **1:N 관계**로 설계되어 있어  
`postId` 존재 여부만으로 이미지 사용 여부를 명확하게 확인할 수 있습니다.

- `postId` 있음 → 사용 중인 이미지  
- `postId` 없음 → 고아 이미지  

#### ✔ Vercel Cron + Cloudflare API로 자동 정리

매일 새벽 자동으로 다음 작업이 실행됩니다.

1. `postId`가 null인 이미지 조회  
2. Cloudflare API로 실제 이미지 삭제  
3. DB에서 Image 레코드 삭제  

→ Cloudflare 저장소가 불필요하게 커지지 않도록 **완전 자동화된 정리 구조**를 구축했습니다.

------------------------------------------------------------------------

## 🛠 Technology Stack

-   **Frontend:** Next.js 14/15, React, TypeScript, React Query v5,
    TailwindCSS, Flowbite-React
-   **Backend:** Prisma, MongoDB
-   **Testing:** Jest, MSW
-   **Deployment:** Vercel

------------------------------------------------------------------------

## ⚙️ Setup & Usage

``` bash
npm run demo
```
